import { Hono } from "hono";
import { HTTPException } from "hono/http-exception";
import { logger } from "hono/logger";
import { cache } from "hono/cache";

import { regexAstToWildcard } from "./wildcard";

const app = new Hono();
app.use(logger());

// Cache all responses via Cloudflare cache API
app.get(
  "*",
  cache({
    cacheName: "rulelist",
    cacheControl: "max-age=1800",
  })
);

// Try to fetch prebuilt JSON rules (generated by CI) only
type RuleItem = { type: "domain" | "full" | "keyword" | "regexp"; value: string; attrs?: string[] };
type RuleJSON = { name: string; rules: RuleItem[] };

const getJsonRules = async (name: string): Promise<RuleJSON | null> => {
  // Points to this repo's prebuilt JSON; adjust if you fork
  const base = "https://raw.githubusercontent.com/Sleepstars/Surge-Geosite-Enhance/refs/heads/main/dist/geosite-json";
  const candidates = Array.from(
    new Set([
      name,
      name.toUpperCase(),
      name.toLowerCase(),
    ])
  );
  for (const n of candidates) {
    const url = `${base}/${encodeURIComponent(n)}.json`;
    try {
      const res = await fetch(url);
      if (!res.ok) continue;
      return (await res.json()) as RuleJSON;
    } catch (_) {
      // try next candidate
    }
  }
  return null;
};

const genSurgeListFromJson = async (
  data: RuleJSON,
  filter: string | null = null
): Promise<string> => {
  const lines: string[] = [];
  for (const r of data.rules) {
    // filter by attribute (e.g., @cn)
    if (filter) {
      const attrs = r.attrs || [];
      if (!attrs.some((a) => a === filter)) {
        continue;
      }
    }
    switch (r.type) {
      case "domain":
        lines.push(`DOMAIN-SUFFIX,${r.value}`);
        break;
      case "full":
        lines.push(`DOMAIN,${r.value}`);
        break;
      case "keyword":
        lines.push(`DOMAIN-KEYWORD,${r.value}`);
        break;
      case "regexp": {
        const wildcard = regexAstToWildcard(r.value);
        const skip = /^[\?\*]+$/.test(wildcard);
        lines.push(`${skip ? "# SKIPPED-DOMAIN-WILDCARD," : "DOMAIN-WILDCARD,"}${wildcard}`);
        break;
      }
    }
  }
  return lines.join("\n");
};

app.get("/geosite/:name_with_filter", async (c) => {
  const raw = c.req.param("name_with_filter").trim();

  if (!raw || raw.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }

  const [rawName, rawFilter] = raw.includes("@") ? raw.split("@", 2) : [raw, null];
  const name = rawName; // keep original case; we try variants when fetching JSON
  const filter = rawFilter ? rawFilter.toLowerCase() : null; // attributes are lowercase like cn

  if (!name || name.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }

  try {
    // Only use prebuilt JSON rules (no v2fly fallback)
    const jsonRules = await getJsonRules(name);
    if (!jsonRules) {
      throw new HTTPException(404, { message: "Rules not found (JSON missing)" });
    }
    const surgeList = await genSurgeListFromJson(jsonRules, filter);
    return c.text(surgeList);
  } catch (error) {
    console.error(`Error processing ${raw}:`, error);
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, {
      message: `Failed to process request: ${error instanceof Error ? error.message : "Unknown error"}`,
    });
  }
});

app.get("/geosite", async (c) => {
  const githubRaw = await fetch(
    "https://raw.githubusercontent.com/Sleepstars/Surge-Geosite-Enhance/main/index.json"
  )
    .then((res) => {
      if (res.ok) {
        return res.json() as Promise<Record<string, string>>;
      }
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${res.status} ${res.statusText}`,
      });
    })
    .catch((err) => {
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${err.message}`,
      });
    });
  return c.json(githubRaw);
});

app.get("/", async (c) => {
  return c.redirect("https://github.com/Sleepstars/Surge-Geosite-Enhance");
});

app.get("/misc/:category/:name", async (c) => {
  const category = c.req.param("category").toLowerCase();
  const name = c.req.param("name").toLowerCase();
  const githubRaw = await fetch(
    `https://raw.githubusercontent.com/Sleepstars/Surge-Geosite-Enhance/refs/heads/main/misc/${category}/${name}.list`
  )
    .then((res) => {
      if (res.ok) {
        return res.text();
      }
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${res.status} ${res.statusText}`,
      });
    })
    .catch((err) => {
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${err.message}`,
      });
    });
  return c.text(githubRaw);
});

export default app;
