import { Hono } from "hono";
import { HTTPException } from "hono/http-exception";
import { logger } from "hono/logger";
import { cache } from "hono/cache";

import { regexAstToWildcard } from "./wildcard";

const app = new Hono();
app.use(logger());

// Cache all responses via Cloudflare cache API
app.get(
  "*",
  cache({
    cacheName: "rulelist",
    cacheControl: "max-age=1800",
  })
);

// Try to fetch prebuilt JSON rules (generated by CI) only
type RuleItem = { type: "domain" | "full" | "keyword" | "regexp"; value: string; attrs?: string[] };
type RuleJSON = { name: string; rules: RuleItem[] };

const getJsonRules = async (name: string, r2?: R2Bucket): Promise<RuleJSON | null> => {
  const candidates = Array.from(
    new Set([
      name,
      name.toUpperCase(),
      name.toLowerCase(),
    ])
  );
  // Only use R2; do not fallback to GitHub or CDN
  if (r2) {
    for (const n of candidates) {
      const key = `geosite-json/${n}.json`;
      try {
        const obj = await r2.get(key);
        if (!obj) continue;
        try {
          const data = (await (obj as any).json?.()) as RuleJSON | undefined;
          if (data && data.name && Array.isArray(data.rules)) return data;
        } catch (_) {
          // ignore
        }
        const ab = await obj.arrayBuffer();
        const text = new TextDecoder().decode(ab);
        return JSON.parse(text) as RuleJSON;
      } catch (_) {
        // try next candidate
      }
    }
  }
  return null;
};

const genSurgeListFromJson = async (
  data: RuleJSON,
  filter: string | null = null
): Promise<string> => {
  const lines: string[] = [];
  for (const r of data.rules) {
    // filter by attribute
    // Supports @cn and @!cn (negation). Attribute compare is case-insensitive.
    if (filter) {
      const neg = filter.startsWith("!");
      const target = (neg ? filter.slice(1) : filter).toLowerCase();
      const attrs = (r.attrs || []).map((a) => a.toLowerCase());
      const has = attrs.includes(target);
      if ((!neg && !has) || (neg && has)) continue;
    }
    switch (r.type) {
      case "domain":
        lines.push(`DOMAIN-SUFFIX,${r.value}`);
        break;
      case "full":
        lines.push(`DOMAIN,${r.value}`);
        break;
      case "keyword":
        lines.push(`DOMAIN-KEYWORD,${r.value}`);
        break;
      case "regexp": {
        const wildcard = regexAstToWildcard(r.value);
        const skip = /^[\?\*]+$/.test(wildcard);
        lines.push(`${skip ? "# SKIPPED-DOMAIN-WILDCARD," : "DOMAIN-WILDCARD,"}${wildcard}`);
        break;
      }
    }
  }
  return lines.join("\n");
};

// ---------- GEOIP (JSON â†’ Surge list) ----------
type GeoIPJSON = { name: string; cidr4?: string[]; cidr6?: string[] };

const getGeoipJson = async (name: string, r2?: R2Bucket): Promise<GeoIPJSON | null> => {
  const candidates = Array.from(new Set([name, name.toUpperCase(), name.toLowerCase()]));
  if (r2) {
    for (const n of candidates) {
      const key = `geoip-json/${n}.json`;
      try {
        const obj = await r2.get(key);
        if (!obj) continue;
        try {
          const data = (await (obj as any).json?.()) as GeoIPJSON | undefined;
          if (data && data.name) return data;
        } catch (_) {}
        const ab = await obj.arrayBuffer();
        const text = new TextDecoder().decode(ab);
        return JSON.parse(text) as GeoIPJSON;
      } catch (_) {
        // try next candidate
      }
    }
  }
  return null;
};

const genSurgeIpListFromJson = async (
  data: GeoIPJSON,
  filter: string | null = null
): Promise<string> => {
  const wantV4 = !filter || filter.toLowerCase() === "v4" || filter.toLowerCase() === "ipv4";
  const wantV6 = !filter || filter.toLowerCase() === "v6" || filter.toLowerCase() === "ipv6";
  const lines: string[] = [];
  if (wantV4) {
    for (const cidr of data.cidr4 || []) {
      lines.push(`IP-CIDR,${cidr},no-resolve`);
    }
  }
  if (wantV6) {
    for (const cidr of data.cidr6 || []) {
      lines.push(`IP-CIDR6,${cidr},no-resolve`);
    }
  }
  return lines.join("\n");
};

// SRS distribution via R2
const getSrsKey = (name: string, filter: string | null): string => {
  // Store keys under geosite/ prefix for organization; '!' allowed in keys
  const fname = filter ? `${name}@${filter}.srs` : `${name}.srs`;
  return `geosite/${fname}`;
};

const getGeoipSrsKey = (name: string, filter: string | null): string => {
  // Store GeoIP SRS under geoip/ prefix
  const fname = filter ? `${name}@${filter}.srs` : `${name}.srs`;
  return `geoip/${fname}`;
};

app.get("/srs/:name_with_filter", async (c) => {
  let raw = c.req.param("name_with_filter").trim();
  if (!raw || raw.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }
  // Require ".srs" suffix in URL, e.g. /srs/APPLE.srs or /srs/APPLE@cn.srs
  if (!raw.toLowerCase().endsWith(".srs")) {
    throw new HTTPException(404, { message: "Not found" });
  }
  raw = raw.slice(0, -4);
  const [rawName, rawFilter] = raw.includes("@") ? raw.split("@", 2) : [raw, null];
  const name = rawName; // keep original case
  const filter = rawFilter ? rawFilter.toLowerCase() : null; // attributes are lowercase like cn

  const bucket = (c as any).env?.SRS_BUCKET as R2Bucket | undefined;
  if (!bucket) {
    throw new HTTPException(500, { message: "SRS bucket not configured" });
  }
  const candidates = Array.from(
    new Set([
      name,
      name.toUpperCase(),
      name.toLowerCase(),
    ])
  );
  let found: R2ObjectBody | null = null;
  let pickedKey = "";
  for (const n of candidates) {
    const key = getSrsKey(n, filter);
    const obj = await bucket.get(key);
    if (obj) {
      found = obj;
      pickedKey = key;
      break;
    }
  }
  const obj = found;
  if (!obj) {
    throw new HTTPException(404, { message: "SRS not found" });
  }
  const headers = new Headers();
  headers.set("content-type", "application/octet-stream");
  const suggested = pickedKey.split("/").pop() || pickedKey;
  headers.set("content-disposition", `inline; filename="${encodeURIComponent(suggested)}"`);
  if (obj.etag) headers.set("etag", obj.etag);
  return new Response(obj.body, { headers });
});

app.get("/geosite/:name_with_filter", async (c) => {
  const raw = c.req.param("name_with_filter").trim();

  if (!raw || raw.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }

  const [rawName, rawFilter] = raw.includes("@") ? raw.split("@", 2) : [raw, null];
  const name = rawName; // keep original case; we try variants when fetching JSON
  const filter = rawFilter ? rawFilter.toLowerCase() : null; // attributes are lowercase like cn

  if (!name || name.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }

  try {
    // Only use prebuilt JSON rules (no v2fly fallback)
    const jsonRules = await getJsonRules(name, (c as any).env?.SRS_BUCKET);
    if (!jsonRules) {
      throw new HTTPException(404, { message: "Rules not found (JSON missing)" });
    }
    const surgeList = await genSurgeListFromJson(jsonRules, filter);
    return c.text(surgeList);
  } catch (error) {
    console.error(`Error processing ${raw}:`, error);
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, {
      message: `Failed to process request: ${error instanceof Error ? error.message : "Unknown error"}`,
    });
  }
});

app.get("/geosite", async (c) => {
  // Prefer KV (single-key cache written by CI), fallback to R2
  const kv = (c as any).env?.GEO_KV as KVNamespace | undefined;
  if (kv) {
    try {
      const cached = (await kv.get("geosite:index", { type: "json", cacheTtl: 3600 })) as
        | Record<string, string>
        | null;
      if (cached && typeof cached === "object") {
        return c.json(cached);
      }
    } catch (_) {
      // ignore and fallback to R2
    }
  }

  const bucket = (c as any).env?.SRS_BUCKET as R2Bucket | undefined;
  if (!bucket) {
    throw new HTTPException(500, { message: "SRS bucket not configured" });
  }
  const obj = await bucket.get("geosite/index.json");
  if (!obj) {
    throw new HTTPException(404, { message: "Index not found" });
  }
  try {
    const data = (await (obj as any).json?.()) as Record<string, string> | undefined;
    if (data && typeof data === "object") return c.json(data);
  } catch (_) {
    // ignore and parse manually
  }
  const ab = await obj.arrayBuffer();
  const text = new TextDecoder().decode(ab);
  return c.json(JSON.parse(text));
});

app.get("/geoip/:name_with_filter", async (c) => {
  const raw = c.req.param("name_with_filter").trim();
  if (!raw || raw.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }
  const [rawName, rawFilter] = raw.includes("@") ? raw.split("@", 2) : [raw, null];
  const name = rawName;
  const filter = rawFilter ? rawFilter.toLowerCase() : null; // supports v4/v6

  try {
    const json = await getGeoipJson(name, (c as any).env?.SRS_BUCKET);
    if (!json) {
      throw new HTTPException(404, { message: "GeoIP not found (JSON missing)" });
    }
    const surgeList = await genSurgeIpListFromJson(json, filter);
    return c.text(surgeList);
  } catch (error) {
    console.error(`Error processing geoip ${raw}:`, error);
    if (error instanceof HTTPException) throw error;
    throw new HTTPException(500, {
      message: `Failed to process request: ${error instanceof Error ? error.message : "Unknown error"}`,
    });
  }
});

app.get("/geoip", async (c) => {
  const kv = (c as any).env?.GEO_KV as KVNamespace | undefined;
  if (kv) {
    try {
      const cached = (await kv.get("geoip:index", { type: "json", cacheTtl: 3600 })) as
        | Record<string, string>
        | null;
      if (cached && typeof cached === "object") {
        return c.json(cached);
      }
    } catch (_) {}
  }
  const bucket = (c as any).env?.SRS_BUCKET as R2Bucket | undefined;
  if (!bucket) {
    throw new HTTPException(500, { message: "SRS bucket not configured" });
  }
  const obj = await bucket.get("geoip/index.json");
  if (!obj) {
    throw new HTTPException(404, { message: "Index not found" });
  }
  try {
    const data = (await (obj as any).json?.()) as Record<string, string> | undefined;
    if (data && typeof data === "object") return c.json(data);
  } catch (_) {}
  const ab = await obj.arrayBuffer();
  const text = new TextDecoder().decode(ab);
  return c.json(JSON.parse(text));
});

app.get("/", async (c) => {
  return c.redirect("https://github.com/Sleepstars/Surge-Geosite-Enhance");
});

// SRS (GeoIP) distribution via R2
app.get("/srs-geoip/:name_with_filter", async (c) => {
  let raw = c.req.param("name_with_filter").trim();
  if (!raw || raw.length === 0) {
    throw new HTTPException(400, { message: "Invalid name parameter" });
  }
  if (!raw.toLowerCase().endsWith(".srs")) {
    throw new HTTPException(404, { message: "Not found" });
  }
  raw = raw.slice(0, -4);
  const [rawName, rawFilter] = raw.includes("@") ? raw.split("@", 2) : [raw, null];
  const name = rawName;
  const filter = rawFilter ? rawFilter.toLowerCase() : null; // v4/v6

  const bucket = (c as any).env?.SRS_BUCKET as R2Bucket | undefined;
  if (!bucket) {
    throw new HTTPException(500, { message: "SRS bucket not configured" });
  }
  const candidates = Array.from(new Set([name, name.toUpperCase(), name.toLowerCase()]));
  let found: R2ObjectBody | null = null;
  let pickedKey = "";
  for (const n of candidates) {
    const key = getGeoipSrsKey(n, filter);
    const obj = await bucket.get(key);
    if (obj) {
      found = obj;
      pickedKey = key;
      break;
    }
  }
  const obj = found;
  if (!obj) {
    throw new HTTPException(404, { message: "SRS not found" });
  }
  const headers = new Headers();
  headers.set("content-type", "application/octet-stream");
  const suggested = pickedKey.split("/").pop() || pickedKey;
  headers.set("content-disposition", `inline; filename="${encodeURIComponent(suggested)}"`);
  if (obj.etag) headers.set("etag", obj.etag);
  return new Response(obj.body, { headers });
});

app.get("/misc/:category/:name", async (c) => {
  const category = c.req.param("category").toLowerCase();
  const name = c.req.param("name").toLowerCase();
  const githubRaw = await fetch(
    `https://raw.githubusercontent.com/Sleepstars/Surge-Geosite-Enhance/refs/heads/main/misc/${category}/${name}.list`
  )
    .then((res) => {
      if (res.ok) {
        return res.text();
      }
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${res.status} ${res.statusText}`,
      });
    })
    .catch((err) => {
      throw new HTTPException(500, {
        message: `Failed to fetch content from GitHub: ${err.message}`,
      });
    });
  return c.text(githubRaw);
});

export default app;
